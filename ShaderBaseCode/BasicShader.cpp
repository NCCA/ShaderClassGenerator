#include "BasicShader.h"
#include <iostream>

// this will be generated by the shader parser code
GLint BasicShader::s_baseColour=0;

// this is generated by default by the tool, use std::shared_ptr as
// a simple factory so we can use static methods and only 1 instance
// think singleton class but with a shared instance of the pointer
std::unique_ptr<BasicShader> BasicShader::getShader()
{
  static std::unique_ptr<BasicShader> shader;

  if(shader ==nullptr)
  {
    shader.reset(new BasicShader);
  }
  return std::move(shader);
}

// ctor loads shaders and is crafted by GUI program
BasicShader::BasicShader() : AbstractShaderProgram ()
{
  static bool initalised=false;

  if(!initalised )
  {
    createShaderProgram();
    initalised=true;
  }
}
// shader source is read by the tool and generated here
// constexpr should compile time replace

constexpr const char * s_vertexShader=
R"(
#version 400 core

layout (location = 0) in vec3  inPosition;
layout (location = 1) in vec3 inColour;
out vec3 vertColour;
uniform vec3 baseColour=vec3(1,1,1);
void main()
{
  gl_Position = vec4(inPosition, 1.0);
  if (inPosition.x >0.0 && inPosition.y<0.5)
   vertColour = inColour;
  else vertColour=baseColour;
}
)";

constexpr const char * s_fragmentShader=
R"(
#version 400 core
in vec3 vertColour;
out vec4 fragColour;
void main()
{
  fragColour = vec4(vertColour,1.0);
}
)";



// this method will be generated by the tool
// What shaders should I support?
// I think Frag / Vert / Geo for now and expand to
// Tess Control / Eval at a later date (should be easy)

bool BasicShader::createShaderProgram()
{

  std::cout<<"Program id "<<AbstractShaderProgram::getProgramID()<<'\n';
  std::cout<<"creating shader program\n";
  createShader(GL_VERTEX_SHADER,s_vertexShader);
  createShader(GL_FRAGMENT_SHADER,s_fragmentShader);
  link();
  bind();
  // for each uniform loaded I will create one of these
  //
  s_baseColour=glGetUniformLocation(s_id,"baseColour");
  return true;
}

// this method will be auto generated
void BasicShader::setBaseColour(GLfloat _1, GLfloat _2, GLfloat _3)
{
  glUniform3f(s_baseColour,_1,_2,_3);
}

